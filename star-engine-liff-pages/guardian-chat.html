<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>守護專家｜Star Engine</title>
    <style>
      :root {
        --bg1: #0f1622;
        --bg2: #0b111b;
        --txt: #eaf0fa;
        --sub: #b6c2d2;
        --blue: #007bff;
      }
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'PingFang TC', 'Noto Sans TC', sans-serif;
        background: linear-gradient(180deg, var(--bg1), var(--bg2));
        color: var(--txt);
      }
      .sheet {
        min-height: 100dvh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 24px;
      }
      .card {
        max-width: 560px;
        width: 100%;
        padding: 24px 22px;
        border-radius: 20px;
        background: rgba(255, 255, 255, 0.06);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
        text-align: center;
      }
      .title {
        font-weight: 700;
        font-size: 20px;
        letter-spacing: 0.3px;
        margin-bottom: 6px;
      }
      .sub {
        color: var(--sub);
        font-size: 14px;
        margin: 0 0 14px;
      }
      .btn {
        display: inline-block;
        margin-top: 8px;
        padding: 12px 18px;
        border-radius: 12px;
        text-decoration: none;
        background: var(--blue);
        color: #fff;
        box-shadow: 0 6px 20px rgba(0, 123, 255, 0.2);
        font-weight: 700;
      }
      .hide {
        display: none;
      }
    </style>
    <script src="config.runtime.js" defer></script>
    <script src="analytics.js" defer></script>
  </head>
  <body>
    <div class="sheet">
      <div id="loading" class="card">
        <div class="title">正在連接守護專家…</div>
        <p class="sub">若 5 秒內沒有跳轉，我們會提供重試與備援選項。</p>
      </div>
      <div id="fallback" class="card hide" aria-live="polite">
        <div class="title">守護專家暫時忙線</div>
        <p class="sub">你仍可直接重新開啟守護專家對話，或改走 AI 入場券備援流程。</p>
        <div class="actions" style="display:grid;gap:12px;margin-top:12px;">
          <a id="retryChat" class="btn" href="#">重新連線守護專家</a>
          <a id="toS0" class="btn" href="#" style="background:#2f3847;">改用 AI 入場券備援</a>
        </div>
      </div>
    </div>
    <script>
      (function () {
        const cfg = window.__STAR_ENGINE_CONFIG__ || {};
        const apiBase = (cfg.API_BASE || '').replace(/\/$/, '');
        const gatewayBase = resolveGatewayBase(cfg, apiBase);
        const params = new URLSearchParams(window.location.search);
        const source = params.get('source') || 'guardian_chat';
        const intent = params.get('intent') || 'see_report';
        const fallbackDefault = cfg.CHATKIT_FALLBACK_URL || cfg.ENTRY_LIFF_URL || 'https://liff.line.me/2008215846-5LwXlWVN';
        const fallback = params.get('fallback') || fallbackDefault;
        let leadId = params.get('lead_id') || '';

        try {
          const storedLead = window.localStorage?.getItem('se_lead_id');
          if (!leadId && storedLead) {
            leadId = storedLead;
          } else if (leadId) {
            window.localStorage?.setItem('se_lead_id', leadId);
          }
        } catch {
          // ignore storage errors
        }

        const chatBase = resolveChatkitBase(cfg);
        const deepLink = chatBase ? buildChatLink(chatBase, { leadId, intent, fallback, source }) : '';
        const skipAutoRedirect = params.get('skip_redirect') === '1';
        const payload = { source, intent, lead_id: leadId || null };

        track('chat_page_open', payload).catch((error) => {
          console.warn('[guardian-chat] track chat_page_open failed', error);
        });

        if (deepLink && !skipAutoRedirect) {
          track('chat_dl_attempt', payload).catch((error) => {
            console.warn('[guardian-chat] track chat_dl_attempt failed', error);
          });
          openChat();
        } else if (deepLink && skipAutoRedirect) {
          console.log('[guardian-chat] debug skip_redirect active, not auto-opening chat');
        }

        let left = false;
        window.addEventListener('pagehide', () => {
          left = true;
        });
        window.addEventListener('blur', () => {
          left = true;
        });
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden') left = true;
        });

        setTimeout(() => {
          if (!left && deepLink) {
            document.getElementById('loading').classList.add('hide');
            const fallbackCard = document.getElementById('fallback');
            fallbackCard.classList.remove('hide');
            pushDebug('fallback_shown', { reason: 'deeplink_timeout', hasDeepLink: true });
            track('chat_retry_shown', { source, fallback, lead_id: leadId || null }).catch((error) => {
              console.warn('[guardian-chat] track chat_retry_shown failed', error);
            });
            const retry = document.getElementById('retryChat');
            if (retry) {
              retry.addEventListener('click', async (event) => {
                event.preventDefault();
                pushDebug('retry_chat_click', { source, leadId: leadId || null });
                try {
                  await track('chat_manual_retry', { source, lead_id: leadId || null });
                } catch (error) {
                  console.warn('[guardian-chat] track chat_manual_retry failed', error);
                }
                try {
                  await track('chat_dl_attempt', { source, lead_id: leadId || null, intent });
                } catch (error) {
                  console.warn('[guardian-chat] track chat_dl_attempt retry failed', error);
                }
                openChat();
              });
            }
            const toS0 = document.getElementById('toS0');
            if (toS0) {
              toS0.setAttribute('href', fallback);
              toS0.addEventListener('click', async (event) => {
                event.preventDefault();
                pushDebug('fallback_entry_click', { source, fallback, leadId: leadId || null });
                try {
                  console.log('[guardian-chat] fallback click', Date.now(), {
                    source,
                    fallback,
                    leadId: leadId || null,
                  });
                } catch {
                  // ignore log failures
                }
                try {
                  await track('chat_fallback_click', { source, fallback, lead_id: leadId || null });
                  await logEvent('need_time', {
                    lead_id: leadId || null,
                    payload: { reason: 'redirect_to_fallback', source, fallback },
                  });
                } catch (error) {
                  console.warn('[guardian-chat] fallback events failed before redirect', error);
                }
                await delay(1000);
                if (fallback) window.location.href = fallback;
              });
            }
          } else if (!left) {
            document.getElementById('loading').classList.add('hide');
            const fallbackCard = document.getElementById('fallback');
            fallbackCard.classList.remove('hide');
            pushDebug('fallback_shown', { reason: 'no_deeplink_available', hasDeepLink: false });
            const retry = document.getElementById('retryChat');
            retry?.classList.add('hide');
            const toS0 = document.getElementById('toS0');
            if (toS0) {
              toS0.setAttribute('href', fallback);
              toS0.addEventListener('click', async (event) => {
                event.preventDefault();
                pushDebug('fallback_entry_click', { source, fallback, leadId: leadId || null });
                try {
                  await track('chat_fallback_click', { source, fallback, lead_id: leadId || null });
                  await logEvent('need_time', {
                    lead_id: leadId || null,
                    payload: { reason: 'redirect_to_fallback', source, fallback },
                  });
                } catch (error) {
                  console.warn('[guardian-chat] fallback events failed before redirect', error);
                }
                await delay(1000);
                if (fallback) window.location.href = fallback;
              });
            }
          }
        }, 5000);

        function resolveChatkitBase(cfg) {
          if (cfg.CHATKIT_APP_ID) {
            return `https://liff.line.me/${cfg.CHATKIT_APP_ID}`;
          }
          if (cfg.CHATKIT_URL) {
            try {
              const url = new URL(cfg.CHATKIT_URL, window.location.href);
              url.search = '';
              url.hash = '';
              return url.toString();
            } catch (error) {
              console.warn('[guardian-chat] invalid CHATKIT_URL', error);
            }
          }
          return '';
        }

        function openChat() {
          if (!deepLink) return;
          window.location.href = deepLink;
        }

        function buildChatLink(base, { leadId, intent, fallback, source }) {
          try {
            const url = new URL(base);
            if (leadId) url.searchParams.set('lead_id', leadId);
            if (intent) url.searchParams.set('intent', intent);
            if (fallback) url.searchParams.set('fallback', fallback);
            if (source) url.searchParams.set('source', source);
            return url.toString();
          } catch (error) {
            console.warn('[guardian-chat] failed to build deeplink', error);
            return '';
          }
        }

        function pushDebug(label, payload) {
          try {
            const entry = { ts: Date.now(), label };
            if (payload !== undefined) entry.payload = payload;
            window.__guardianDebug = window.__guardianDebug || [];
            window.__guardianDebug.push(entry);
          } catch {
            // ignore debug storage errors
          }
        }

        function delay(ms) {
          return new Promise((resolve) => setTimeout(resolve, ms));
        }

        async function track(eventName, payload) {
          if (!eventName) return false;
          try {
            pushDebug('track_invoked', { event: eventName, payload });
            console.log('[guardian-chat] track invoked', eventName, payload);
          } catch {
            // ignore
          }
          if (window.starAnalytics && typeof window.starAnalytics.track === 'function') {
            try {
              window.starAnalytics.track(eventName, payload);
            } catch (error) {
              console.warn('[guardian-chat] starAnalytics.track failed', error);
            }
          }
          if (!apiBase) return false;
          const endpoint = `${apiBase}/analytics`;
          const body = JSON.stringify({ ev: eventName, ts: Date.now(), ...payload });
          let beaconSent = false;
          try {
            pushDebug('analytics_payload', { endpoint, payload });
            console.log('[guardian-chat] analytics payload', endpoint, payload);
          } catch {
            // ignore console failures
          }
          try {
            const blob = new Blob([body], { type: 'application/json' });
            beaconSent = navigator.sendBeacon(endpoint, blob);
            if (beaconSent) {
              pushDebug('analytics_send_beacon');
              console.log('[guardian-chat] analytics sent via sendBeacon');
              return true;
            }
            console.warn('[guardian-chat] sendBeacon returned false, retrying with fetch');
          } catch (error) {
            console.warn('[guardian-chat] sendBeacon failed', error);
          }
          try {
            const response = await fetch(endpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body,
              keepalive: true,
            });
            pushDebug('analytics_fetch_completed', { ok: response?.ok ?? null });
            console.log('[guardian-chat] analytics fetch completed', response?.ok);
            return response?.ok ?? false;
          } catch (error) {
            console.error('[guardian-chat] analytics fetch failed', error);
            throw error;
          }
        }

        async function logEvent(eventName, payload) {
          if (!eventName) return false;
          const bodyObject = { ev: eventName, ts: new Date().toISOString(), ...payload };
          const body = JSON.stringify(bodyObject);
          const gatewayUrl = gatewayBase ? `${gatewayBase}/log_event` : '';
          const hasLeadId =
            bodyObject.lead_id !== undefined &&
            bodyObject.lead_id !== null &&
            String(bodyObject.lead_id).trim().length > 0;

          if (!hasLeadId) {
            pushDebug('log_event_no_lead', {
              source: payload?.payload?.source || 'guardian_chat',
              fallback: payload?.payload?.fallback || '',
            });
            return track('chat_need_time_no_lead', {
              source: payload?.payload?.source || 'guardian_chat',
              fallback: payload?.payload?.fallback || '',
            });
          }

          if (gatewayUrl) {
            try {
              await fetch(gatewayUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-ChatKit-Lead-ID': String(bodyObject.lead_id || ''),
                  'X-ChatKit-Source': bodyObject.payload?.source || 'guardian_chat',
                },
                body,
                keepalive: true,
              });
              pushDebug('log_event_gateway');
              console.log('[guardian-chat] gateway log_event sent');
              return true;
            } catch (error) {
              console.warn('[guardian-chat] gateway log_event failed, trying fallback', error);
            }
          }

          if (!apiBase) return false;
          const fallbackEndpoint = `${apiBase}/ai/log_event`;
          try {
            const response = await fetch(fallbackEndpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body,
              keepalive: true,
            });
            pushDebug('log_event_fetch_completed', { ok: response?.ok ?? null });
            console.log('[guardian-chat] log_event fetch completed', response?.ok);
            return response?.ok ?? false;
          } catch (error) {
            console.error('[guardian-chat] log_event fetch failed', error);
            throw error;
          }
        }

        function resolveGatewayBase(cfg, apiBase) {
          const base =
            typeof cfg.API_GATEWAY_BASE === 'string' && cfg.API_GATEWAY_BASE.trim().length > 0
              ? cfg.API_GATEWAY_BASE
              : apiBase
              ? `${apiBase}/ai`
              : '';
          return base.replace(/\/$/, '');
        }

        async function safeParseError(response) {
          try {
            return await response.text();
          } catch (error) {
            return 'unknown';
          }
        }
      })();
    </script>
  </body>
</html>
